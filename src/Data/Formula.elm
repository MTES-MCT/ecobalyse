module Data.Formula exposing (..)

import Data.Impact as Impact
import Data.Process as Process exposing (Process)
import Data.Transport as Transport exposing (Transport)
import Data.Unit as Unit
import Energy exposing (Energy)
import Mass exposing (Mass)
import Quantity



-- Waste


{-| Compute source material mass needed and waste generated by the operation.
-}
genericWaste : Mass -> Mass -> { waste : Mass, mass : Mass }
genericWaste processWaste baseMass =
    let
        waste =
            baseMass
                |> Quantity.multiplyBy (Mass.inKilograms processWaste)
    in
    { waste = waste, mass = baseMass |> Quantity.plus waste }


{-| Compute source material mass needed and waste generated by the operation from
ratioed pristine/recycled material processes data.
-}
materialRecycledWaste :
    { pristineWaste : Mass
    , recycledWaste : Mass
    , recycledRatio : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
materialRecycledWaste { pristineWaste, recycledWaste, recycledRatio } baseMass =
    let
        ( recycledMass, pristineMass ) =
            ( baseMass |> Quantity.multiplyBy recycledRatio
            , baseMass |> Quantity.multiplyBy (1 - recycledRatio)
            )

        ( ratioedRecycledWaste, ratioedPristineWaste ) =
            ( recycledMass |> Quantity.multiplyBy (Mass.inKilograms recycledWaste)
            , pristineMass |> Quantity.multiplyBy (Mass.inKilograms pristineWaste)
            )

        waste =
            Quantity.plus ratioedRecycledWaste ratioedPristineWaste
    in
    { waste = waste
    , mass = Quantity.sum [ pristineMass, recycledMass, waste ]
    }


{-| Compute source material mass needed and waste generated by the operation, according to
material & product waste data.
-}
makingWaste :
    { processWaste : Mass
    , pcrWaste : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
makingWaste { processWaste, pcrWaste } baseMass =
    let
        mass =
            -- (product weight + textile waste for confection) / (1 - PCR product waste rate)
            Mass.kilograms <|
                (Mass.inKilograms baseMass + (Mass.inKilograms baseMass * Mass.inKilograms processWaste))
                    / (1 - pcrWaste)
    in
    { waste = Quantity.minus baseMass mass, mass = mass }



-- Impacts


materialAndSpinningImpact :
    Impact.Trigram
    -> ( Process, Process ) -- Inbound: Material processes (recycled, non-recycled)
    -> Float -- Ratio of recycled material (bewteen 0 and 1)
    -> Mass
    -> Unit.Impact
materialAndSpinningImpact trigram ( recycledProcess, nonRecycledProcess ) ratio =
    Unit.ratioedForKg
        ( Process.getImpact trigram recycledProcess
        , Process.getImpact trigram nonRecycledProcess
        )
        ratio


pureMaterialAndSpinningImpact : Impact.Trigram -> Process -> Mass -> Unit.Impact
pureMaterialAndSpinningImpact trigram process =
    Unit.forKg (Process.getImpact trigram process)


dyeingImpact :
    Impact.Trigram
    -> ( Process, Process ) -- Inbound: Dyeing processes (low, high)
    -> Float -- Low/high dyeing process ratio
    -> Process -- Outbound: country heat impact
    -> Process -- Outbound: country electricity impact
    -> Mass
    -> { heat : Energy, kwh : Energy, impact : Unit.Impact }
dyeingImpact trigram ( dyeingLowProcess, dyeingHighProcess ) highDyeingWeighting heatProcess elecProcess baseMass =
    let
        lowDyeingWeighting =
            1 - highDyeingWeighting

        ( lowDyeingMass, highDyeingMass ) =
            ( baseMass |> Quantity.multiplyBy lowDyeingWeighting
            , baseMass |> Quantity.multiplyBy highDyeingWeighting
            )

        dyeingImpact_ =
            Quantity.sum
                [ Unit.forKg (Process.getImpact trigram dyeingLowProcess) lowDyeingMass
                , Unit.forKg (Process.getImpact trigram dyeingHighProcess) highDyeingMass
                ]

        heatMJ =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.heat)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.heat)
                  )
                |> Energy.megajoules

        heatImpact =
            heatMJ |> Unit.forMJ (Process.getImpact trigram heatProcess)

        electricity =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.elec)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.elec)
                  )
                |> Energy.megajoules

        elecImpact =
            electricity |> Unit.forKWh (Process.getImpact trigram elecProcess)
    in
    { impact = Quantity.sum [ dyeingImpact_, heatImpact, elecImpact ]
    , heat = heatMJ
    , kwh = electricity
    }


makingImpact :
    Impact.Trigram
    -> { makingProcess : Process, countryElecProcess : Process }
    -> Mass
    -> { kwh : Energy, impact : Unit.Impact }
makingImpact trigram { makingProcess, countryElecProcess } _ =
    -- Note: In Base Impacts, impacts are precomputed per "item", and are
    --       therefore not mass-dependent.
    { kwh = makingProcess.elec
    , impact =
        makingProcess.elec
            |> Unit.forKWh (Process.getImpact trigram countryElecProcess)
    }


knittingImpact :
    Impact.Trigram
    -> { elec : Energy, countryElecProcess : Process }
    -> Mass
    -> { kwh : Energy, impact : Unit.Impact }
knittingImpact trigram { elec, countryElecProcess } baseMass =
    let
        electricityKWh =
            Energy.kilowattHours
                (Mass.inKilograms baseMass * Energy.inKilowattHours elec)
    in
    { kwh = electricityKWh
    , impact = electricityKWh |> Unit.forKWh (Process.getImpact trigram countryElecProcess)
    }


weavingImpact :
    Impact.Trigram
    ->
        { elecPppm : Float
        , countryElecProcess : Process
        , ppm : Int
        , grammage : Int
        }
    -> Mass
    -> { kwh : Energy, impact : Unit.Impact }
weavingImpact trigram { elecPppm, countryElecProcess, ppm, grammage } baseMass =
    let
        electricityKWh =
            (Mass.inKilograms baseMass * 1000 * toFloat ppm / toFloat grammage)
                * elecPppm
                |> Energy.kilowattHours
    in
    { kwh = electricityKWh
    , impact = electricityKWh |> Unit.forKWh (Process.getImpact trigram countryElecProcess)
    }



-- Transports


transportRatio : Float -> Transport -> Transport
transportRatio airTransportRatio ({ road, sea, air } as transport) =
    let
        roadSeaRatio =
            Transport.roadSeaTransportRatio transport
    in
    { transport
        | road = road |> Quantity.multiplyBy (roadSeaRatio * (1 - airTransportRatio))
        , sea = sea |> Quantity.multiplyBy ((1 - roadSeaRatio) * (1 - airTransportRatio))
        , air = air |> Quantity.multiplyBy airTransportRatio
    }
