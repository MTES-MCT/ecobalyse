module Data.Formula exposing (..)

import Data.Co2 as Co2 exposing (Co2e)
import Data.FwE as FwE exposing (Pe)
import Data.Process exposing (Process)
import Data.Transport as Transport exposing (Transport)
import Energy exposing (Energy)
import Mass exposing (Mass)
import Quantity



-- Waste


{-| Compute source material mass needed and waste generated by the operation.
-}
genericWaste : Mass -> Mass -> { waste : Mass, mass : Mass }
genericWaste processWaste baseMass =
    let
        waste =
            baseMass
                |> Quantity.multiplyBy (Mass.inKilograms processWaste)
    in
    { waste = waste, mass = baseMass |> Quantity.plus waste }


{-| Compute source material mass needed and waste generated by the operation from
ratioed pristine/recycled material processes data.
-}
materialRecycledWaste :
    { pristineWaste : Mass
    , recycledWaste : Mass
    , recycledRatio : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
materialRecycledWaste { pristineWaste, recycledWaste, recycledRatio } baseMass =
    let
        ( recycledMass, pristineMass ) =
            ( baseMass |> Quantity.multiplyBy recycledRatio
            , baseMass |> Quantity.multiplyBy (1 - recycledRatio)
            )

        ( ratioedRecycledWaste, ratioedPristineWaste ) =
            ( recycledMass |> Quantity.multiplyBy (Mass.inKilograms recycledWaste)
            , pristineMass |> Quantity.multiplyBy (Mass.inKilograms pristineWaste)
            )

        waste =
            Quantity.plus ratioedRecycledWaste ratioedPristineWaste
    in
    { waste = waste
    , mass = Quantity.sum [ pristineMass, recycledMass, waste ]
    }


{-| Compute source material mass needed and waste generated by the operation, according to
material & product waste data.
-}
makingWaste :
    { processWaste : Mass
    , pcrWaste : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
makingWaste { processWaste, pcrWaste } baseMass =
    let
        mass =
            -- (product weight + textile waste for confection) / (1 - PCR product waste rate)
            Mass.kilograms <|
                (Mass.inKilograms baseMass + (Mass.inKilograms baseMass * Mass.inKilograms processWaste))
                    / (1 - pcrWaste)
    in
    { waste = Quantity.minus baseMass mass, mass = mass }



-- Co2 score


dyeingImpacts :
    ( Process, Process ) -- Inbound: Dyeing processes (low, high)
    -> Float -- Low/high dyeing process ratio
    -> Process -- Outbound: country heat impact
    -> Process -- Outbound: country electricity impact
    -> Mass
    -> { co2 : Co2e, fwe : Pe, heat : Energy, kwh : Energy }
dyeingImpacts ( dyeingLowProcess, dyeingHighProcess ) highDyeingWeighting heatProcess elecProcess baseMass =
    let
        lowDyeingWeighting =
            1 - highDyeingWeighting

        ( lowDyeingMass, highDyeingMass ) =
            ( baseMass |> Quantity.multiplyBy lowDyeingWeighting
            , baseMass |> Quantity.multiplyBy highDyeingWeighting
            )

        dyeingCo2_ =
            Quantity.sum
                [ Co2.forKg dyeingLowProcess.climateChange lowDyeingMass
                , Co2.forKg dyeingHighProcess.climateChange highDyeingMass
                ]

        dyeingFwe =
            Quantity.sum
                [ FwE.forKg dyeingLowProcess.freshwaterEutrophication lowDyeingMass
                , FwE.forKg dyeingHighProcess.freshwaterEutrophication highDyeingMass
                ]

        heatMJ =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.heat)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.heat)
                  )
                |> Energy.megajoules

        heatCo2 =
            heatMJ |> Co2.forMJ heatProcess.climateChange

        heatFwe =
            heatMJ |> FwE.forMJ heatProcess.freshwaterEutrophication

        electricity =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.elec)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.elec)
                  )
                |> Energy.megajoules

        elecCo2 =
            electricity |> Co2.forKWh elecProcess.climateChange

        elecFwe =
            electricity |> FwE.forKWh elecProcess.freshwaterEutrophication
    in
    { co2 = Quantity.sum [ dyeingCo2_, heatCo2, elecCo2 ]
    , fwe = Quantity.sum [ dyeingFwe, heatFwe, elecFwe ]
    , heat = heatMJ
    , kwh = electricity
    }


makingCo2 :
    { makingProcess : { process | elec : Energy }
    , countryElecCC : Co2e
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
makingCo2 { makingProcess, countryElecCC } _ =
    -- Note: In Base Impacts, Energy for the Making step is expressed
    --       in MJ per item, so it's not mass-dependent.
    let
        co2 =
            makingProcess.elec
                |> Co2.forKWh countryElecCC
    in
    { co2 = co2, kwh = makingProcess.elec }


knittingCo2 :
    { elec : Energy
    , elecCC : Co2e
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
knittingCo2 { elec, elecCC } baseMass =
    let
        electricityKWh =
            Energy.kilowattHours
                (Mass.inKilograms baseMass * Energy.inKilowattHours elec)
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.forKWh elecCC
    }


weavingCo2 :
    { elecPppm : Float
    , elecCC : Co2e
    , ppm : Int
    , grammage : Int
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
weavingCo2 { elecPppm, elecCC, ppm, grammage } baseMass =
    let
        electricityKWh =
            (Mass.inKilograms baseMass * 1000 * toFloat ppm / toFloat grammage)
                * elecPppm
                |> Energy.kilowattHours
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.forKWh elecCC
    }



-- Transports


transportRatio : Float -> Transport -> Transport
transportRatio airTransportRatio ({ road, sea, air } as transport) =
    let
        roadSeaRatio =
            Transport.roadSeaTransportRatio transport
    in
    { transport
        | road = road |> Quantity.multiplyBy (roadSeaRatio * (1 - airTransportRatio))
        , sea = sea |> Quantity.multiplyBy ((1 - roadSeaRatio) * (1 - airTransportRatio))
        , air = air |> Quantity.multiplyBy airTransportRatio
    }
