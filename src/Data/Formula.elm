module Data.Formula exposing (..)

import Data.Co2 as Co2 exposing (Co2e)
import Data.Process exposing (Process)
import Data.Transport as Transport exposing (Transport)
import Energy exposing (Energy)
import Mass exposing (Mass)
import Quantity



-- Waste


{-| Compute source material mass needed and waste generated by the operation.
-}
genericWaste : Mass -> Mass -> { waste : Mass, mass : Mass }
genericWaste processWaste baseMass =
    let
        waste =
            baseMass
                |> Quantity.multiplyBy (Mass.inKilograms processWaste)
    in
    { waste = waste, mass = baseMass |> Quantity.plus waste }


{-| Compute source material mass needed and waste generated by the operation from
ratioed pristine/recycled material processes data.
-}
materialRecycledWaste :
    { pristineWaste : Mass
    , recycledWaste : Mass
    , recycledRatio : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
materialRecycledWaste { pristineWaste, recycledWaste, recycledRatio } baseMass =
    let
        ( recycledMass, pristineMass ) =
            ( baseMass |> Quantity.multiplyBy recycledRatio
            , baseMass |> Quantity.multiplyBy (1 - recycledRatio)
            )

        ( ratioedRecycledWaste, ratioedPristineWaste ) =
            ( recycledMass |> Quantity.multiplyBy (Mass.inKilograms recycledWaste)
            , pristineMass |> Quantity.multiplyBy (Mass.inKilograms pristineWaste)
            )

        waste =
            Quantity.plus ratioedRecycledWaste ratioedPristineWaste
    in
    { waste = waste
    , mass = Quantity.sum [ pristineMass, recycledMass, waste ]
    }


{-| Compute source material mass needed and waste generated by the operation, according to
material & product waste data.
-}
makingWaste :
    { processWaste : Mass
    , pcrWaste : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
makingWaste { processWaste, pcrWaste } baseMass =
    let
        mass =
            -- (product weight + textile waste for confection) / (1 - PCR product waste rate)
            Mass.kilograms <|
                (Mass.inKilograms baseMass + (Mass.inKilograms baseMass * Mass.inKilograms processWaste))
                    / (1 - pcrWaste)
    in
    { waste = Quantity.minus baseMass mass, mass = mass }



-- Co2 score


dyeingCo2 :
    ( Process, Process )
    -> Float
    -> Co2e
    -> Co2e
    -> Mass
    -> { co2 : Co2e, heat : Energy, kwh : Energy }
dyeingCo2 ( dyeingLowProcess, dyeingHighProcess ) highDyeingWeighting heatCC elecCC baseMass =
    let
        lowDyeingWeighting =
            1 - highDyeingWeighting

        ( lowDyeingMass, highDyeingMass ) =
            ( baseMass |> Quantity.multiplyBy lowDyeingWeighting
            , baseMass |> Quantity.multiplyBy highDyeingWeighting
            )

        dyeingCo2_ =
            Quantity.sum
                [ Co2.forKg dyeingLowProcess.climateChange lowDyeingMass
                , Co2.forKg dyeingHighProcess.climateChange highDyeingMass
                ]

        heatMJ =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.heat)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.heat)
                  )
                |> Energy.megajoules

        heatCo2 =
            heatMJ |> Co2.forMJ heatCC

        electricity =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.elec)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.elec)
                  )
                |> Energy.megajoules

        elecCo2 =
            electricity |> Co2.forKWh elecCC
    in
    { co2 = Quantity.sum [ dyeingCo2_, heatCo2, elecCo2 ]
    , heat = heatMJ
    , kwh = electricity
    }


makingCo2 :
    { makingProcess : { process | elec : Energy }
    , countryElecCC : Co2e
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
makingCo2 { makingProcess, countryElecCC } _ =
    -- Note: In Base Impacts, Energy for the Making step is expressed
    --       in MJ per item, so it's not mass-dependent.
    let
        co2 =
            makingProcess.elec
                |> Co2.forKWh countryElecCC
    in
    { co2 = co2, kwh = makingProcess.elec }


knittingCo2 :
    { elec : Energy
    , elecCC : Co2e
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
knittingCo2 { elec, elecCC } baseMass =
    let
        electricityKWh =
            Energy.kilowattHours
                (Mass.inKilograms baseMass * Energy.inKilowattHours elec)
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.forKWh elecCC
    }


weavingCo2 :
    { elecPppm : Float
    , elecCC : Co2e
    , ppm : Int
    , grammage : Int
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
weavingCo2 { elecPppm, elecCC, ppm, grammage } baseMass =
    let
        electricityKWh =
            (Mass.inKilograms baseMass * 1000 * toFloat ppm / toFloat grammage)
                * elecPppm
                |> Energy.kilowattHours
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.forKWh elecCC
    }



-- Transports


transportRatio : Float -> Transport -> Transport
transportRatio airTransportRatio ({ road, sea, air } as transport) =
    let
        roadSeaRatio =
            Transport.roadSeaTransportRatio transport
    in
    { transport
        | road = road |> Quantity.multiplyBy (roadSeaRatio * (1 - airTransportRatio))
        , sea = sea |> Quantity.multiplyBy ((1 - roadSeaRatio) * (1 - airTransportRatio))
        , air = air |> Quantity.multiplyBy airTransportRatio
    }
