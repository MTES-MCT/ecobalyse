module Data.Formula exposing (..)

import Data.Co2 as Co2 exposing (Co2e)
import Data.Process exposing (Process)
import Data.Transport as Transport exposing (Transport)
import Energy exposing (Energy)
import Mass exposing (Mass)
import Quantity



-- Waste


{-| Compute source material mass needed and waste generated by the operation.
-}
genericWaste : Mass -> Mass -> { waste : Mass, mass : Mass }
genericWaste processWaste baseMass =
    let
        waste =
            baseMass
                |> Quantity.multiplyBy (Mass.inKilograms processWaste)
    in
    { waste = waste, mass = baseMass |> Quantity.plus waste }


{-| Compute source material mass needed and waste generated by the operation from
ratioed pristine/recycled material processes data.
-}
materialRecycledWaste :
    { pristineWaste : Mass
    , recycledWaste : Mass
    , recycledRatio : Float
    }
    -> Mass
    -> { waste : Mass, mass : Mass }
materialRecycledWaste { pristineWaste, recycledWaste, recycledRatio } baseMass =
    let
        ( recycledMass, pristineMass ) =
            ( baseMass |> Quantity.multiplyBy recycledRatio
            , baseMass |> Quantity.multiplyBy (1 - recycledRatio)
            )

        ( ratioedRecycledWaste, ratioedPristineWaste ) =
            ( recycledMass |> Quantity.multiplyBy (Mass.inKilograms recycledWaste)
            , pristineMass |> Quantity.multiplyBy (Mass.inKilograms pristineWaste)
            )

        waste =
            Quantity.plus ratioedRecycledWaste ratioedPristineWaste
    in
    { waste = waste
    , mass = Quantity.sum [ pristineMass, recycledMass, waste ]
    }


{-| Compute source material mass needed and waste generated by the operation, according to
material & product waste data.
-}
makingWaste : { processWaste : Mass, pcrWaste : Float } -> Mass -> { waste : Mass, mass : Mass }
makingWaste { processWaste, pcrWaste } baseMass =
    let
        mass =
            -- (product weight + textile waste for confection) / (1 - PCR product waste rate)
            Mass.kilograms <|
                (Mass.inKilograms baseMass + (Mass.inKilograms baseMass * Mass.inKilograms processWaste))
                    / (1 - pcrWaste)
    in
    { waste = Quantity.minus baseMass mass, mass = mass }



-- Co2 score


dyeingCo2 :
    ( Process, Process )
    -> Float
    -> Co2e
    -> Co2e
    -> Mass
    -> { co2 : Co2e, heat : Energy, kwh : Energy }
dyeingCo2 ( dyeingLowProcess, dyeingHighProcess ) highDyeingWeighting heatCC elecCC baseMass =
    let
        lowDyeingWeighting =
            1 - highDyeingWeighting

        ( lowDyeingMass, highDyeingMass ) =
            ( baseMass |> Quantity.multiplyBy lowDyeingWeighting
            , baseMass |> Quantity.multiplyBy highDyeingWeighting
            )

        dyeingCo2_ =
            Quantity.sum
                [ Co2.co2ePerMass dyeingLowProcess.climateChange lowDyeingMass
                , Co2.co2ePerMass dyeingHighProcess.climateChange highDyeingMass
                ]

        heatMJ =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.heat)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.heat)
                  )
                |> Energy.megajoules

        heatCo2 =
            -- FIXME: bug in Excel, we should be using KWh here; keeping for BC for now
            Co2.inKgCo2e heatCC
                |> (*) (Energy.inMegajoules heatMJ)
                |> Co2.kgCo2e

        electricity =
            Mass.inKilograms baseMass
                * ((highDyeingWeighting * Energy.inMegajoules dyeingHighProcess.elec)
                    + (lowDyeingWeighting * Energy.inMegajoules dyeingLowProcess.elec)
                  )
                |> Energy.megajoules

        elecCo2 =
            electricity |> Co2.co2ePerKWh elecCC
    in
    { co2 = Quantity.sum [ dyeingCo2_, heatCo2, elecCo2 ]
    , heat = heatMJ
    , kwh = electricity
    }


{-| Compute co2 from climate change impact and mass
-}
materialCo2 : Co2e -> Mass -> Co2e
materialCo2 climateChange =
    Co2.co2ePerMass climateChange


{-| Compute co2 from ratioed material climate change impact and mass
-}
materialRecycledCo2 :
    { pristineClimateChange : Co2e
    , recycledClimateChange : Co2e
    , recycledRatio : Float
    }
    -> Mass
    -> Co2e
materialRecycledCo2 { pristineClimateChange, recycledClimateChange, recycledRatio } baseMass =
    let
        ( recycledCo2, pristineCo2 ) =
            ( baseMass
                |> Quantity.multiplyBy recycledRatio
                |> Co2.co2ePerMass recycledClimateChange
            , baseMass
                |> Quantity.multiplyBy (1 - recycledRatio)
                |> Co2.co2ePerMass pristineClimateChange
            )
    in
    Quantity.plus recycledCo2 pristineCo2


makingCo2 :
    { makingClimateChange : Co2e
    , makingElec : Energy
    , countryElecClimateChange : Co2e
    }
    -> Mass
    -> { kwh : Energy, co2 : Co2e }
makingCo2 { makingClimateChange, makingElec, countryElecClimateChange } baseMass =
    let
        makingCo2_ =
            baseMass
                |> Co2.co2ePerMass makingClimateChange

        kwh =
            makingElec
                |> Quantity.multiplyBy (Mass.inKilograms baseMass)

        elecCo2 =
            kwh
                |> Co2.co2ePerKWh countryElecClimateChange
    in
    { co2 = Quantity.plus makingCo2_ elecCo2, kwh = kwh }


knittingCo2 : Process -> Co2e -> Mass -> { kwh : Energy, co2 : Co2e }
knittingCo2 fabricProcess elecCC baseMass =
    let
        electricityKWh =
            Energy.kilowattHours
                (Mass.inKilograms baseMass * Energy.inKilowattHours fabricProcess.elec)
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.co2ePerKWh elecCC
    }


weavingCo2 : Process -> Co2e -> Int -> Int -> Mass -> { kwh : Energy, co2 : Co2e }
weavingCo2 fabricProcess elecCC ppm grammage baseMass =
    let
        electricityKWh =
            (Mass.inKilograms baseMass * 1000 * toFloat ppm / toFloat grammage)
                * fabricProcess.elec_pppm
                |> Energy.kilowattHours
    in
    { kwh = electricityKWh
    , co2 = electricityKWh |> Co2.co2ePerKWh elecCC
    }



-- Transports


transportRatio : Float -> Transport.Summary -> Transport
transportRatio airTransportRatio ({ road, sea, air } as summary) =
    let
        roadSeaRatio =
            Transport.roadSeaTransportRatio summary
    in
    { road = (road * roadSeaRatio) * (1 - airTransportRatio)
    , sea = (sea * (1 - roadSeaRatio)) * (1 - airTransportRatio)
    , air = air * airTransportRatio
    }
