"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _crossSpawn() {
  const data = _interopRequireDefault(require("cross-spawn"));
  _crossSpawn = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _terser() {
  const data = require("terser");
  _terser = function () {
    return data;
  };
  return data;
}
function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));
  _diagnostic = function () {
    return data;
  };
  return data;
}
function _nodeElmCompiler() {
  const data = _interopRequireDefault(require("node-elm-compiler"));
  _nodeElmCompiler = function () {
    return data;
  };
  return data;
}
function _elmHot() {
  const data = _interopRequireDefault(require("elm-hot"));
  _elmHot = function () {
    return data;
  };
  return data;
}
var _loadConfig = require("./loadConfig");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// $FlowFixMe
// $FlowFixMe
let isWorker;
try {
  let worker_threads = require('worker_threads');
  isWorker = worker_threads.threadId > 0;
} catch (_) {
  isWorker = false;
}
var _default = exports.default = new (_plugin().Transformer)({
  loadConfig({
    config
  }) {
    return (0, _loadConfig.load)({
      config
    });
  },
  async transform({
    asset,
    options,
    logger
  }) {
    const elmBinary = (0, _loadConfig.elmBinaryPath)();
    const compilerConfig = {
      spawn: _crossSpawn().default,
      cwd: _path().default.dirname(asset.filePath),
      // $FlowFixMe[sketchy-null-string]
      debug: !options.env.PARCEL_ELM_NO_DEBUG && options.mode !== 'production',
      optimize: asset.env.shouldOptimize,
      report: 'json'
    };
    asset.invalidateOnEnvChange('PARCEL_ELM_NO_DEBUG');
    const extraSources = resolveExtraSources({
      asset,
      logger
    });
    extraSources.forEach(filePath => {
      asset.invalidateOnFileChange(filePath);
    });
    const sources = [asset.filePath, ...extraSources];
    const dependencies = await Promise.all(sources.map(source => _nodeElmCompiler().default.findAllDependencies(source)));
    const uniqueDeps = new Set(dependencies.flat());
    Array.from(uniqueDeps).forEach(filePath => {
      asset.invalidateOnFileChange(filePath);
    });

    // Workaround for `chdir` not working in workers
    // this can be removed after https://github.com/isaacs/node-graceful-fs/pull/200 was mergend and used in parcel
    // $FlowFixMe[method-unbinding]
    process.chdir.disabled = isWorker;
    let code;
    try {
      code = await compileToString(_nodeElmCompiler().default, elmBinary, sources, compilerConfig);
    } catch (e) {
      let compilerJson = e.message.split('\n')[1];
      let compilerDiagnostics = JSON.parse(compilerJson);
      if (compilerDiagnostics.type === 'compile-errors') {
        throw new (_diagnostic().default)({
          diagnostic: compilerDiagnostics.errors.flatMap(elmCompileErrorToParcelDiagnostics)
        });
      }

      // compilerDiagnostics.type === "error"
      // happens for example when compiled in prod mode with Debug.log in code
      throw new (_diagnostic().default)({
        diagnostic: formatElmError(compilerDiagnostics, '')
      });
    }
    if (options.hmrOptions) {
      code = _elmHot().default.inject(code);
    }
    if (compilerConfig.optimize) code = await minifyElmOutput(code);
    asset.type = 'js';
    asset.setCode(code);
    return [asset];
  }
}); // gather extra modules that should be added to the compilation process
function resolveExtraSources({
  asset,
  logger
}) {
  const dirname = _path().default.dirname(asset.filePath);
  const relativePaths = asset.query.getAll('with');
  if (relativePaths.length > 0) {
    logger.info({
      message: (0, _diagnostic().md)`Compiling elm with additional sources: ${_diagnostic().md.bold(JSON.stringify(relativePaths))}`
    });
  }
  return relativePaths.map(relPath => _path().default.join(dirname, relPath));
}
function compileToString(elm, elmBinary, sources, config) {
  return elm.compileToString(sources, {
    pathToElm: elmBinary,
    ...config
  });
}
let elmPureFuncs = ['F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9'];
async function minifyElmOutput(source) {
  // Recommended minification
  // Based on: http://elm-lang.org/0.19.0/optimize
  let result = await (0, _terser().minify)(source, {
    compress: {
      keep_fargs: false,
      passes: 2,
      pure_funcs: elmPureFuncs,
      pure_getters: true,
      unsafe: true,
      unsafe_comps: true
    },
    mangle: {
      reserved: elmPureFuncs
    }
  });
  if (result.code != null) return result.code;
  throw result.error;
}
function formatMessagePiece(piece) {
  if (piece.string) {
    if (piece.underline) {
      return (0, _diagnostic().md)`${_diagnostic().md.underline(piece.string)}`;
    }
    return (0, _diagnostic().md)`${_diagnostic().md.bold(piece.string)}`;
  }
  return (0, _diagnostic().md)`${piece}`;
}
function elmCompileErrorToParcelDiagnostics(error) {
  const relativePath = _path().default.relative(process.cwd(), error.path);
  return error.problems.map(problem => formatElmError(problem, relativePath));
}
function formatElmError(problem, relativePath) {
  const padLength = Math.max(80 - 5 - problem.title.length - relativePath.length, 1);
  const dashes = '-'.repeat(padLength);
  const message = ['', `-- ${problem.title} ${dashes} ${relativePath}`, '', problem.message.map(formatMessagePiece).join('')].join('\n');
  return {
    message,
    origin: '@parcel/elm-transformer',
    stack: '' // set stack to empty since it is not useful
  };
}